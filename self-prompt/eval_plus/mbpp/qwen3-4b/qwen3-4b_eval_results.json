{"date": "2025-12-11 12:57", "hash": "ee43ecabebf20deef4bb776a405ac5b1", "eval": {"Mbpp/745": [{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum + 1):\n        digits = set(str(num))\n        if all(num % int(digit) == 0 for digit in digits):\n            result.append(num)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 22]], "plus_fail_tests": [[100, 200]]}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "\ndef max_sublist_length(lists):\n    max_len = 0\n    for sublist in lists:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n    return max_len", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/562", "solution": "\ndef max_sublist_length(lists):\n    max_len = 0\n    for sublist in lists:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n    return max_len", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/562", "solution": "# Example list of lists\nlist_of_lists = [\n    [1, 2, 3],\n    [4, 5],\n    [6, 7, 8, 9],\n    [10]\n]\n\n# Call the function\nmax_length = max_sublist_length(list_of_lists)\n\n# Output the result\nprint(\"Maximum sublist length:\", max_length)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "assert difference(3) == 30\n\"\"\"\n\ndef difference(n):\n    # Calculate the sum of cubes of first n natural numbers\n    sum_cubes = sum(i**3 for i in range(1, n+1))\n    # Calculate the sum of first n natural numbers\n    sum_numbers = sum(i for i in range(1, n+1))\n    # Return the difference\n    return sum_cubes - sum_numbers\n```\n\nLet me test this with the given assertion:\ndifference(3) should be 30.\n\nSum of cubes for 1, 2, 3 is 1^3 + 2^3 + 3^3 = 1 + 8 + 27 = 36\nSum of numbers is 1 + 2 + 3 = 6\nDifference is 36 - 6 = 30. Correct.\n\nThis function should work for any positive integer n. The code uses generator expressions for efficiency and clarity. The time complexity is O(n), which is optimal for this problem.\n</think>\n\nTo solve the problem of finding the difference between the sum of cubes of the first `n` natural numbers and the sum of the first `n` natural numbers, we can break the task into two main parts:\n\n1. **Calculate the sum of the cubes of the first `n` natural numbers.**\n2. **Calculate the sum of the first `n` natural numbers.**\n3. **Compute the difference between the two sums.**\n\n---\n\n### \u2705 **Approach**\n\n- **Sum of cubes of first `n` natural numbers**:\n  The sum of cubes of the first `n` natural numbers is given by the formula:\n  $$\n  \\text{Sum of cubes} = \\left( \\frac{n(n+1)}{2} \\right)^2\n  $$\n  This is a well-known mathematical identity that allows us to compute the sum in constant time, $O(1)$, instead of iterating through all numbers.\n\n- **Sum of first `n` natural numbers**:\n  The sum of the first `n` natural numbers is given by the formula:\n  $$\n  \\text{Sum of numbers} = \\frac{n(n+1)}{2}\n  $$\n\n- **Difference**:\n  Using the two formulas above, the difference is:\n  $$\n  \\text{Difference} = \\left( \\frac{n(n+1)}{2} \\right)^2 - \\frac{n(n+1)}{2}\n  $$\n\nThis approach is **mathematically efficient** and **computationally optimal**, with a time complexity of $O(1)$.\n\n---\n\n### \ud83e\udde0 **Python Implementation**\n\n```python\ndef difference(n):\n    \"\"\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/555", "solution": "\ndef difference_of_cubes_and_sum(n):\n    # Calculate sum of cubes of first n natural numbers\n    sum_cubes = sum(i**3 for i in range(1, n+1))\n    # Calculate sum of first n natural numbers\n    sum_numbers = sum(range(1, n+1))\n    # Return the difference\n    return sum_cubes - sum_numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/555", "solution": "\ndef difference_of_cubes_and_sum(n):\n    # Calculate sum of cubes of first n natural numbers\n    sum_cubes = sum(i**3 for i in range(1, n+1))\n    # Calculate sum of first n natural numbers\n    sum_numbers = sum(range(1, n+1))\n    # Return the difference\n    return sum_cubes - sum_numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/555", "solution": "\ndef difference_of_cubes_and_sum(n):\n    # Calculate sum of cubes of first n natural numbers\n    sum_cubes = sum(i**3 for i in range(1, n+1))\n    # Calculate sum of first n natural numbers\n    sum_numbers = sum(range(1, n+1))\n    # Return the difference\n    return sum_cubes - sum_numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "def toggle_case(s):\n    \"\"\"\n    Toggles the case of each character in the input string.\n    \n    Parameters:\n    s (str): The input string whose characters' cases will be toggled.\n    \n    Returns:\n    str: A new string where each uppercase character becomes lowercase and vice versa.\n    \n    Example:\n    >>> toggle_case(\"Hello, World!\")\n    'hELLO, wORLD!'\n    \"\"\"\n    return s.swapcase()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/557", "solution": "def toggle_case(s):\n    \"\"\"\n    Toggles the case of each character in the input string.\n    \n    Parameters:\n    s (str): The input string whose characters' cases will be toggled.\n    \n    Returns:\n    str: A new string where each uppercase character becomes lowercase and vice versa.\n    \n    Example:\n    >>> toggle_case(\"Hello, World!\")\n    'hELLO, wORLD!'\n    \"\"\"\n    return s.swapcase()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/557", "solution": "def toggle_case(s):\n    \"\"\"\n    Toggles the case of each character in the input string.\n    \n    Parameters:\n    s (str): The input string whose characters' cases will be toggled.\n    \n    Returns:\n    str: A new string where each uppercase character becomes lowercase and vice versa.\n    \n    Example:\n    >>> toggle_case(\"Hello, World!\")\n    'hELLO, wORLD!'\n    \"\"\"\n    return s.swapcase()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "def interchange_first_last(lst):\n    \"\"\"\n    Interchange the first and last elements of a list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    list: A new list with the first and last elements swapped.\n    \"\"\"\n    # Check if the list is empty or has only one element\n    if len(lst) < 2:\n        return lst  # Return the original list if it's too short\n\n    # Swap the first and last elements\n    lst[0], lst[-1] = lst[-1], lst[0]\n\n    return lst", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/591", "solution": "\ndef interchange_first_last(lst):\n    # Check if the list is not empty and has at least two elements\n    if len(lst) < 2:\n        return lst  # Return the original list if it's too short\n    # Swap the first and last elements\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "def digit_distance(num1: int, num2: int) -> int:\n    \"\"\"\n    Calculate the digit distance between two integers.\n\n    The digit distance is the sum of the absolute differences of corresponding digits.\n    If the numbers have different lengths, return -1.\n\n    Parameters:\n    num1 (int): First integer.\n    num2 (int): Second integer.\n\n    Returns:\n    int: The digit distance if the numbers have the same length, otherwise -1.\n    \"\"\"\n    # Convert the numbers to strings to iterate over each digit\n    str_num1 = str(num1)\n    str_num2 = str(num2)\n    \n    # Check if the numbers have the same length\n    if len(str_num1) != len(str_num2):\n        return -1  # Return -1 if the numbers have different lengths\n    \n    # Calculate the digit distance by summing the absolute differences of each corresponding digit\n    distance = 0\n    for d1, d2 in zip(str_num1, str_num2):\n        distance += abs(int(d1) - int(d2))\n    \n    return distance", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/558", "solution": "def digit_distance(num1: int, num2: int) -> int:\n    \"\"\"\n    Calculate the digit distance between two integers.\n\n    The digit distance is the sum of the absolute differences of corresponding digits.\n    If the numbers have different lengths, return -1.\n\n    Parameters:\n    num1 (int): First integer.\n    num2 (int): Second integer.\n\n    Returns:\n    int: The digit distance if the numbers have the same length, otherwise -1.\n    \"\"\"\n    # Convert the numbers to strings to iterate over each digit\n    str_num1 = str(num1)\n    str_num2 = str(num2)\n    \n    # Check if the numbers have the same length\n    if len(str_num1) != len(str_num2):\n        return -1  # Return -1 if the numbers have different lengths\n    \n    # Calculate the digit distance by summing the absolute differences of each corresponding digit\n    distance = 0\n    for d1, d2 in zip(str_num1, str_num2):\n        distance += abs(int(d1) - int(d2))\n    \n    return distance", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/558", "solution": "def digit_distance(num1: int, num2: int) -> int:\n    \"\"\"\n    Calculate the digit distance between two integers.\n\n    The digit distance is the sum of the absolute differences of corresponding digits.\n    If the numbers have different lengths, return -1.\n\n    Parameters:\n    num1 (int): First integer.\n    num2 (int): Second integer.\n\n    Returns:\n    int: The digit distance if the numbers have the same length, otherwise -1.\n    \"\"\"\n    # Convert the numbers to strings to iterate over each digit\n    str_num1 = str(num1)\n    str_num2 = str(num2)\n    \n    # Check if the numbers have the same length\n    if len(str_num1) != len(str_num2):\n        return -1  # Return -1 if the numbers have different lengths\n    \n    # Calculate the digit distance by summing the absolute differences of each corresponding digit\n    distance = 0\n    for d1, d2 in zip(str_num1, str_num2):\n        distance += abs(int(d1) - int(d2))\n    \n    return distance", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "def find_difference(arr):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a given array.\n    \n    Parameters:\n    arr (list): A list of numerical values.\n    \n    Returns:\n    int or float: The difference between the maximum and minimum values in the array.\n    \n    Raises:\n    ValueError: If the input array is empty or contains non-numeric values.\n    \n    Example:\n    >>> find_difference([10, 20, 30, 40])\n    30\n    >>> find_difference([5, 1, 9, 3])\n    8\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Input array cannot be empty.\")\n    \n    if not all(isinstance(x, (int, float)) for x in arr):\n        raise ValueError(\"All elements in the array must be numeric.\")\n    \n    return max(arr) - min(arr)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/588", "solution": "# Example 1\nnumbers = [10, 2, 5, 1, 7]\nprint(find_difference(numbers))  # Output: 9 (10 - 1)\n\n# Example 2\nnumbers = [4, 4, 4]\nprint(find_difference(numbers))  # Output: 0 (4 - 4)\n\n# Example 3\nnumbers = []\nprint(find_difference(numbers))  # Raises ValueError: The input array is empty.", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/588", "solution": "# Example 1\nnumbers = [10, 2, 5, 1, 8]\nprint(find_difference(numbers))  # Output: 9 (10 - 1)\n\n# Example 2\nnumbers = [3, 3, 3]\nprint(find_difference(numbers))  # Output: 0 (3 - 3)\n\n# Example 3\nnumbers = [5]\nprint(find_difference(numbers))  # Output: 0 (5 - 5)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "def extract_even_elements(nested_tuple):\n    \"\"\"\n    Extracts all even integers from a nested mixed tuple.\n\n    Parameters:\n    nested_tuple (tuple): A tuple that may contain integers and other tuples.\n\n    Returns:\n    list: A list of even integers found in the nested structure.\n    \"\"\"\n    even_elements = []\n\n    for element in nested_tuple:\n        if isinstance(element, int) and element % 2 == 0:\n            even_elements.append(element)\n        elif isinstance(element, tuple):\n            even_elements.extend(extract_even_elements(element))\n\n    return even_elements", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/580", "solution": "\ndef extract_even_elements(nested_tuple):\n    # Initialize an empty list to store even elements\n    even_elements = []\n    \n    # Iterate through each element in the nested tuple\n    for element in nested_tuple:\n        # Check if the element is an integer and even\n        if isinstance(element, int) and element % 2 == 0:\n            even_elements.append(element)\n        # If the element is a tuple, recursively check its elements\n        elif isinstance(element, tuple):\n            # Recursively call the function on the nested tuple\n            even_elements.extend(extract_even_elements(element))\n    \n    return even_elements", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/580", "solution": "\ndef extract_even_elements(nested_tuple):\n    # Initialize an empty list to store even elements\n    even_elements = []\n    \n    # Iterate through each element in the nested tuple\n    for element in nested_tuple:\n        # Check if the element is an integer and even\n        if isinstance(element, int) and element % 2 == 0:\n            even_elements.append(element)\n        # If the element is a tuple, recursively check its elements\n        elif isinstance(element, tuple):\n            # Recursively call the function on the nested tuple\n            even_elements.extend(extract_even_elements(element))\n    \n    return even_elements", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "\ndef catalan(n):\n    # Using dynamic programming to compute the nth Catalan number\n    # Initialize a list to store intermediate results\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    \n    return catalan[n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/583", "solution": "\ndef catalan(n):\n    # Using dynamic programming to compute the nth Catalan number\n    # Initialize a list to store intermediate results\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    \n    return catalan[n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/583", "solution": "\ndef catalan(n):\n    # Using dynamic programming to compute the nth Catalan number\n    # Initialize a list to store intermediate results\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    \n    return catalan[n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "def Split(lst):\n    return [x for x in lst if x % 2 != 0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/554", "solution": "# Example 1: Mixed list with integers, floats, and strings\nmixed = [1, 2.5, 3, \"a\", 5, 6, 7.0, 8, 9, \"b\"]\nprint(find_odd_numbers(mixed))  # Output: [1, 3, 5, 9]\n\n# Example 2: List with only non-integer elements\nmixed = [\"x\", 3.14, \"y\", 2.71]\nprint(find_odd_numbers(mixed))  # Output: []\n\n# Example 3: List with no odd numbers\nmixed = [2, 4, 6, 8]\nprint(find_odd_numbers(mixed))  # Output: []\n\n# Example 4: List with negative numbers\nmixed = [-3, -2, 0, 1, 2, 3]\nprint(find_odd_numbers(mixed))  # Output: [-3, 1, 3]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/554", "solution": "def find_odd_numbers(mixed_list):\n    \"\"\"\n    Find and return all odd numbers from a mixed list.\n    \n    Parameters:\n    mixed_list (list): A list containing various elements, including integers.\n    \n    Returns:\n    list: A list of integers from the input that are odd (i.e., not divisible by 2).\n    \n    Raises:\n    TypeError: If the input is not a list.\n    ValueError: If any element in the list is not an integer.\n    \"\"\"\n    \n    # Check if the input is a list\n    if not isinstance(mixed_list, list):\n        raise TypeError(\"Input must be a list.\")\n    \n    # Filter and check for odd numbers\n    odd_numbers = []\n    for item in mixed_list:\n        if not isinstance(item, int):\n            raise ValueError(f\"List contains non-integer element: {item}\")\n        if item % 2 != 0:\n            odd_numbers.append(item)\n    \n    return odd_numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/554", "solution": "\ndef find_odd_numbers(mixed_list):\n    return [num for num in mixed_list if num % 2 != 0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "\ndef last_digit_factorial(n):\n    # Handle the special case where n is 0 or 1\n    if n == 0 or n == 1:\n        return 0\n    # For numbers >= 5, the last digit of factorial is 0 because 5*2=10\n    if n >= 5:\n        return 0\n    # Calculate the factorial and return the last digit\n    result = 1\n    for i in range(2, n+1):\n        result = (result * i) % 10\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/577", "solution": "def last_digit_factorial(n):\n    \"\"\"\n    Returns the last digit of the factorial of a given non-negative integer n.\n    \n    Parameters:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The last digit of n! (n factorial).\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return 1  # 0! = 1\n    \n    last_digit = 1\n    for i in range(1, n + 1):\n        last_digit = (last_digit * i) % 10\n    \n    return last_digit", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/577", "solution": "def last_digit_factorial(n):\n    \"\"\"\n    Returns the last digit of the factorial of a given number n.\n    \n    Parameters:\n    n (int): The number for which the factorial's last digit is to be found.\n    \n    Returns:\n    int: The last digit of n! (n factorial).\n    \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    if n >= 5:\n        return 0\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % 10\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "\ndef remove_leading_zeros(ip_address):\n    # Split the IP address into its four octets\n    octets = ip_address.split('.')\n    # Process each octet to remove leading zeros\n    processed_octets = [str(int(octet)) for octet in octets]\n    # Join the processed octets back into an IP address string\n    return '.'.join(processed_octets)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/593", "solution": "\ndef remove_leading_zeros(ip):\n    # Split the IP address into its four parts\n    parts = ip.split('.')\n    # Process each part to remove leading zeros\n    processed_parts = [str(int(part)) for part in parts]\n    # Join the processed parts back into an IP address\n    return '.'.join(processed_parts)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "def sum_and_average(n):\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    # Sum of first n natural numbers using the formula: n*(n+1)//2\n    total_sum = n * (n + 1) // 2\n    \n    # Average is sum divided by n\n    average = total_sum / n\n    \n    return total_sum, average", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/599", "solution": "def sum_and_average(n):\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    # Sum of first n natural numbers using the formula: n*(n+1)//2\n    total_sum = n * (n + 1) // 2\n    \n    # Average is sum divided by n\n    average = total_sum / n\n    \n    return total_sum, average", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(arr, n):\n    # Count of even numbers\n    even_count = 0\n    # Count of odd numbers\n    odd_count = 0\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    # The number of pairs with odd XOR is even_count * odd_count\n    return even_count * odd_count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 2], 10]]}, {"task_id": "Mbpp/556", "solution": "\ndef count_odd_xor_pairs(arr):\n    # Count the number of even and odd numbers in the array\n    even_count = 0\n    odd_count = 0\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The number of pairs with XOR as odd is even_count * odd_count\n    return even_count * odd_count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/556", "solution": "\ndef count_odd_xor_pairs(arr):\n    # Count the number of even and odd numbers in the array\n    even_count = 0\n    odd_count = 0\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The number of pairs with XOR as odd is even_count * odd_count\n    return even_count * odd_count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/556", "solution": "\ndef count_odd_xor_pairs(arr):\n    # Count the number of even and odd numbers in the array\n    even_count = 0\n    odd_count = 0\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The number of pairs with XOR as odd is even_count * odd_count\n    return even_count * odd_count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "def sort_sublists(input_list):\n    \"\"\"\n    Sorts each sublist of strings in the given list of lists in place.\n\n    Parameters:\n    input_list (list of list of str): A list where each element is a list of strings.\n\n    Returns:\n    list of list of str: The input list with each sublist sorted in ascending order.\n    \"\"\"\n    for sublist in input_list:\n        sublist.sort()\n    return input_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/569", "solution": "def sort_sublists_in_place(lst):\n    \"\"\"\n    Sorts each sublist in the given list of lists in-place.\n    \n    Parameters:\n    lst (list of lists): A list where each element is a list of strings.\n    \n    Returns:\n    list of lists: The original list with each sublist sorted.\n    \"\"\"\n    for sublist in lst:\n        sublist.sort()\n    return lst", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/569", "solution": "def sort_sublists(lst):\n    \"\"\"\n    Sorts each sublist of strings in the given list of lists in place.\n\n    Parameters:\n    lst (list of list of str): A list where each element is a list of strings.\n\n    Returns:\n    list of list of str: The modified list with all sublists sorted in ascending order.\n    \"\"\"\n    for sublist in lst:\n        sublist.sort()\n    return lst", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2):\n    \"\"\"\n    Interleave two lists of the same length.\n\n    Parameters:\n        list1 (list): First list.\n        list2 (list): Second list.\n\n    Returns:\n        list: A new list with elements interleaved from list1 and list2.\n\n    Raises:\n        ValueError: If the lists are not of the same length.\n    \"\"\"\n    # Check if the lists are of the same length\n    if len(list1) != len(list2):\n        raise ValueError(\"Lists must be of the same length\")\n\n    # Interleave the elements from both lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n\n    return interleaved", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]]], "plus_fail_tests": [[[], [], []]]}, {"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2):\n    \"\"\"\n    Interleave two lists of the same length.\n\n    Parameters:\n        list1 (list): First list.\n        list2 (list): Second list.\n\n    Returns:\n        list: A new list with elements interleaved from list1 and list2.\n\n    Raises:\n        ValueError: If the lists are not of the same length.\n    \"\"\"\n    # Check if the lists are of the same length\n    if len(list1) != len(list2):\n        raise ValueError(\"Lists must be of the same length\")\n    \n    # Interleave the elements from both lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n    \n    return interleaved", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]]], "plus_fail_tests": [[[], [], []]]}, {"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2):\n    \"\"\"\n    Interleave two lists of the same length.\n\n    Parameters:\n        list1 (list): First list.\n        list2 (list): Second list.\n\n    Returns:\n        list: A new list with elements interleaved from list1 and list2.\n\n    Raises:\n        ValueError: If the lists are not of the same length.\n    \"\"\"\n    # Check if the lists are of the same length\n    if len(list1) != len(list2):\n        raise ValueError(\"Lists must be of the same length\")\n    \n    # Interleave the elements from both lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n    \n    return interleaved", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]]], "plus_fail_tests": [[[], [], []]]}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "def tuple_size(input_tuple):\n    \"\"\"\n    Returns the size (number of elements) of the given tuple.\n\n    Parameters:\n    input_tuple (tuple): The tuple whose size is to be determined.\n\n    Returns:\n    int: The number of elements in the tuple.\n    \"\"\"\n    return len(input_tuple)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["A", 1, "B", 2, "C", 3]]], "plus_fail_tests": [[[[1, "Raju"], [2, "Nikhil"], [3, "Deepanshu"]]]]}, {"task_id": "Mbpp/596", "solution": "def tuple_size(input_tuple):\n    \"\"\"\n    Returns the size (number of elements) of the given tuple.\n\n    Parameters:\n    input_tuple (tuple): The tuple whose size is to be determined.\n\n    Returns:\n    int: The number of elements in the tuple.\n    \"\"\"\n    return len(input_tuple)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["A", 1, "B", 2, "C", 3]]], "plus_fail_tests": [[[[1, "Raju"], [2, "Nikhil"], [3, "Deepanshu"]]]]}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "def product_of_unique_numbers(numbers):\n    \"\"\"\n    Calculate the product of unique numbers in a given list.\n\n    Parameters:\n    numbers (list): A list of integers.\n\n    Returns:\n    int: The product of numbers that appear exactly once in the list.\n         Returns 1 if there are no such numbers.\n    \"\"\"\n    # Step 1: Count the frequency of each number\n    frequency = {}\n    for num in numbers:\n        frequency[num] = frequency.get(num, 0) + 1\n\n    # Step 2: Filter numbers that appear exactly once\n    unique_numbers = [num for num in numbers if frequency[num] == 1]\n\n    # Step 3: Calculate the product of unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n\n    return product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/573", "solution": "\ndef product_of_unique_numbers(lst):\n    # Create a frequency dictionary\n    frequency = {}\n    for num in lst:\n        frequency[num] = frequency.get(num, 0) + 1\n    # Filter numbers with frequency 1\n    unique_numbers = [num for num in lst if frequency[num] == 1]\n    # Calculate the product\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/573", "solution": "def product_of_unique_numbers(lst):\n    \"\"\"\n    Calculate the product of unique numbers in a given list.\n    \n    A unique number is defined as a number that appears exactly once in the list.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    int: The product of all unique numbers in the list. If there are no unique numbers,\n         returns 1 (as the product of an empty list is conventionally 1).\n    \"\"\"\n    # Step 1: Count the frequency of each number\n    frequency = {}\n    for num in lst:\n        frequency[num] = frequency.get(num, 0) + 1\n\n    # Step 2: Filter numbers that appear exactly once\n    unique_numbers = [num for num in lst if frequency[num] == 1]\n\n    # Step 3: Calculate the product of unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n\n    return product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "# Example 1: Normal case\nprint(difference_even_odd([3, 5, 2, 7, 4]))  # Output: 2 - 3 = -1\n\n# Example 2: First even is at index 2, first odd at index 0\nprint(difference_even_odd([5, 2, 7, 4]))     # Output: 2 - 5 = -3\n\n# Example 3: List with only even numbers\ntry:\n    print(difference_even_odd([2, 4, 6, 8]))\nexcept ValueError as e:\n    print(e)  # Output: List must contain at least one even and one odd number.\n\n# Example 4: List with only odd numbers\ntry:\n    print(difference_even_odd([3, 5, 7, 9]))\nexcept ValueError as e:\n    print(e)  # Output: List must contain at least one even and one odd number.", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/594", "solution": "\ndef difference_even_odd(nums):\n    even = 0\n    odd = 0\n    for num in nums:\n        if num % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    return even - odd", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "\ndef kth_element(arr1, arr2, k):\n    # Ensure arr1 is the shorter array\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    # Now arr2 is the longer array\n    # Initialize pointers\n    low, high = 0, len(arr1) - 1\n    while low <= high:\n        mid1 = (low + high) // 2\n        mid2 = k - mid1 - 1\n        # Check if mid1 is within bounds\n        if mid1 < 0 or mid1 > len(arr1) - 1:\n            return arr2[mid2]\n        if mid2 < 0 or mid2 > len(arr2) - 1:\n            return arr1[mid1]\n        # Compare the elements\n        if arr1[mid1] > arr2[mid2]:\n            high = mid1 - 1\n        else:\n            low = mid1 + 1\n    # If the loop ends, the kth element is the max of the last elements of the two arrays\n    return max(arr1[low-1], arr2[mid2])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/597", "solution": "\ndef kth_element(arr1, arr2, k):\n    # Ensure arr1 is the smaller array\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    m, n = len(arr1), len(arr2)\n    low, high = 0, m\n    while low <= high:\n        mid1 = (low + high) // 2\n        mid2 = k - mid1 - 1\n        # Check if mid1 is out of bounds\n        if mid1 < 0:\n            return arr2[mid2]\n        if mid2 < 0:\n            return arr1[mid1]\n        # Check if mid1 is beyond the end of arr1\n        if mid1 >= m:\n            return arr2[mid2]\n        if mid2 >= n:\n            return arr1[mid1]\n        # Compare the elements\n        if arr1[mid1] > arr2[mid2]:\n            high = mid1 - 1\n        else:\n            low = mid1 + 1\n    return arr1[mid1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    \"\"\"\n    Calculate the sum of the digits of a non-negative integer.\n\n    Parameters:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The sum of the digits of the input number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    total = 0\n    while n > 0:\n        total += n % 10\n        n = n // 10\n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    total = 0\n    while n > 0:\n        total += n % 10\n        n = n // 10\n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    \"\"\"\n    Calculate the sum of the digits of a non-negative integer.\n\n    Parameters:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The sum of the digits of the input number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    total = 0\n    while n > 0:\n        total += n % 10\n        n = n // 10\n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "def extract_values(s):\n    \"\"\"\n    Extracts all substrings that are enclosed in double quotation marks from a given string.\n\n    Parameters:\n    s (str): The input string containing quoted values.\n\n    Returns:\n    list: A list of strings that are found between double quotation marks.\n    \"\"\"\n    # Split the string by double quotes and filter out any empty strings\n    return [part for part in s.split('\"') if part.strip()]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["\"Python\", \"PHP\", \"Java\""]], "plus_fail_tests": [["This is a test input."]]}, {"task_id": "Mbpp/563", "solution": "def extract_values(s):\n    \"\"\"\n    Extracts all substrings that are enclosed between double quotation marks\n    in the given string.\n\n    Parameters:\n    s (str): The input string containing quoted values.\n\n    Returns:\n    list: A list of strings that are found between double quotes.\n    \"\"\"\n    # Split the string by double quotes and filter out any empty strings\n    return [part for part in s.split('\"') if part.strip()]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["\"Python\", \"PHP\", \"Java\""]], "plus_fail_tests": [["This is a test input."]]}, {"task_id": "Mbpp/563", "solution": "def extract_values(s):\n    \"\"\"\n    Extracts all substrings that are enclosed in double quotation marks from a given string.\n\n    Parameters:\n    s (str): The input string containing quoted values.\n\n    Returns:\n    list: A list of strings that are found between double quotation marks.\n    \"\"\"\n    # Split the string by double quotes and filter out any empty strings\n    return [part for part in s.split('\"') if part.strip()]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["\"Python\", \"PHP\", \"Java\""]], "plus_fail_tests": [["This is a test input."]]}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "def is_subarray(sub_arr, main_arr):\n    \"\"\"\n    Check if sub_arr is a subarray of main_arr.\n    \n    Parameters:\n    sub_arr (list): The subarray to search for.\n    main_arr (list): The main array to search within.\n    \n    Returns:\n    bool: True if sub_arr is a subarray of main_arr, False otherwise.\n    \"\"\"\n    # Handle edge cases\n    if not sub_arr:\n        return True  # An empty array is a subarray of any array\n    if not main_arr:\n        return False  # An empty main array cannot contain a non-empty subarray\n    \n    len_sub = len(sub_arr)\n    len_main = len(main_arr)\n    \n    # Iterate through all possible starting positions in main_arr\n    for i in range(len_main - len_sub + 1):\n        # Check if the subarray matches starting at index i\n        if main_arr[i:i+len_sub] == sub_arr:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/576", "solution": "\ndef is_subarray(arr, main_arr):\n    # Check if the main array is empty\n    if not main_arr:\n        return False\n    # Check if the subarray is empty\n    if not arr:\n        return True\n    # Iterate through the main array to find the starting index\n    for i in range(len(main_arr) - len(arr) + 1):\n        # Check if the subarray matches from this index\n        match = True\n        for j in range(len(arr)):\n            if main_arr[i + j] != arr[j]:\n                match = False\n                break\n        if match:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/576", "solution": "def is_subarray(sub_arr, main_arr):\n    \"\"\"\n    Check if sub_arr is a subarray of main_arr.\n    \n    Parameters:\n    sub_arr (list): The subarray to search for.\n    main_arr (list): The main array to search within.\n    \n    Returns:\n    bool: True if sub_arr is a subarray of main_arr, False otherwise.\n    \"\"\"\n    # Handle edge cases\n    if not sub_arr:\n        return True  # An empty array is a subarray of any array\n    if not main_arr:\n        return False  # An empty main array cannot contain a non-empty subarray\n    \n    len_sub = len(sub_arr)\n    len_main = len(main_arr)\n    \n    # Iterate through all possible starting positions in main_arr\n    for i in range(len_main - len_sub + 1):\n        # Check if the subarray matches starting at index i\n        if main_arr[i:i+len_sub] == sub_arr:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "\ndef count_unequal_pairs(arr):\n    n = len(arr)\n    # Total number of possible pairs\n    total_pairs = n * (n - 1) // 2\n    # Number of equal element pairs\n    equal_pairs = 0\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    for count in freq.values():\n        equal_pairs += count * (count - 1) // 2\n    # Subtract equal pairs from total to get unequal pairs\n    return total_pairs - equal_pairs", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/564", "solution": "\ndef count_unequal_pairs(arr):\n    n = len(arr)\n    # Total number of possible pairs\n    total_pairs = n * (n - 1) // 2\n    # Number of equal element pairs\n    equal_pairs = 0\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    for count in freq.values():\n        equal_pairs += count * (count - 1) // 2\n    # Subtract equal pairs from total to get unequal pairs\n    return total_pairs - equal_pairs", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/564", "solution": "def count_unequal_pairs(arr):\n    from collections import Counter\n\n    # Count the frequency of each element\n    freq = Counter(arr)\n    unique_elements = list(freq.keys())\n    \n    count = 0\n    # Iterate over all unique pairs (a, b) where a < b\n    for i in range(len(unique_elements)):\n        for j in range(i + 1, len(unique_elements)):\n            a = unique_elements[i]\n            b = unique_elements[j]\n            if a != b:\n                count += freq[a] * freq[b]\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "def is_armstrong(n):\n    \"\"\"\n    Check if a given number is an Armstrong number.\n\n    An Armstrong number (or narcissistic number) is a number that is equal to the sum of its own digits\n    each raised to the power of the number of digits.\n\n    Parameters:\n    n (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is an Armstrong number, False otherwise.\n    \"\"\"\n    # Convert the number to a string to iterate over its digits\n    digits = str(n)\n    # Get the number of digits\n    length = len(digits)\n    # Initialize the sum of the powers to 0\n    sum_of_powers = 0\n\n    # Iterate over each digit in the number\n    for digit in digits:\n        # Convert the digit back to integer and compute its power\n        sum_of_powers += int(digit) ** length\n\n    # Check if the sum of the powers equals the original number\n    return sum_of_powers == n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/598", "solution": "def is_armstrong(n):\n    \"\"\"\n    Check if a number is an Armstrong number.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is an Armstrong number, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False  # Negative numbers are not considered Armstrong numbers\n\n    digits = str(n)\n    length = len(digits)\n    sum_of_powers = 0\n\n    for digit in digits:\n        sum_of_powers += int(digit) ** length\n\n    return sum_of_powers == n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "def union_of_tuples(t1, t2):\n    # Convert tuples to sets to remove duplicates\n    set1 = set(t1)\n    set2 = set(t2)\n    \n    # Find the union of the two sets\n    union_set = set1.union(set2)\n    \n    # Convert the union set back to a tuple\n    return tuple(union_set)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/560", "solution": "def union_of_tuples(t1, t2):\n    \"\"\"\n    Returns a tuple containing all unique elements from both input tuples.\n    \n    Parameters:\n    t1 (tuple): First input tuple.\n    t2 (tuple): Second input tuple.\n    \n    Returns:\n    tuple: A new tuple containing the union of elements from t1 and t2.\n    \"\"\"\n    # Convert tuples to sets to remove duplicates\n    set1 = set(t1)\n    set2 = set(t2)\n    \n    # Find the union of the two sets\n    union_set = set1.union(set2)\n    \n    # Convert the result back to a tuple and return\n    return tuple(union_set)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/560", "solution": "def union_of_tuples(t1, t2):\n    result = []\n    for num in t1:\n        if num not in result:\n            result.append(num)\n    for num in t2:\n        if num not in result:\n            result.append(num)\n    return tuple(result)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/590", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "import heapq", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/585", "solution": "import heapq", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/585", "solution": "    # Use a max-heap to find the n most expensive items\n    # Since Python's heapq module only implements a min-heap, we can invert the values\n    # to simulate a max-heap by storing negative values\n    # We'll use a heap of size n to keep track of the n most expensive items\n    # The heap will store tuples of (-price, item) to simulate a max-heap\n    \n    # Initialize the heap with the first n elements (or all elements if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Create a heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use a min-heap to store the n most expensive items, but since we're using negative values,\n    # the smallest negative (i.e., largest actual price) will be at the top\n    \n    # Initialize the heap with the first n elements (or all if there are fewer than n)\n    # We'll use", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "def create_empty_dict_list(n):\n    \"\"\"\n    Create a list of empty dictionaries.\n\n    Parameters:\n    n (int): The number of empty dictionaries to create.\n\n    Returns:\n    list: A list containing n empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(n)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/568", "solution": "def create_empty_dict_list(n):\n    return [{} for _ in range(n)]\n\n# Example usage\nempty_dicts = create_empty_dict_list(3)\nprint(empty_dicts)  # Output: [{} , {} , {}]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/568", "solution": "def create_empty_dict_list(n):\n    \"\"\"\n    Create a list of empty dictionaries.\n\n    Parameters:\n    n (int): The number of empty dictionaries to create.\n\n    Returns:\n    list: A list containing n empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(n)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "\ndef is_sorted(lst):\n    # Check if the list is sorted in ascending order\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/567", "solution": "def is_sorted(lst):\n    \"\"\"\n    Check if the given list is sorted in ascending order.\n\n    Parameters:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if the list is sorted in ascending order, False otherwise.\n    \"\"\"\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/567", "solution": "def is_sorted(lst):\n    \"\"\"\n    Check if the given list is sorted in ascending order.\n\n    Parameters:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if the list is sorted in ascending order, False otherwise.\n    \"\"\"\n    # Iterate through the list and compare each element with the next\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "input_str = \"hello\"\nresult = split_string_into_characters(input_str)\nprint(result)  # Output: ['h', 'e', 'l', 'l', 'o']", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/565", "solution": "input_str = \"hello\"\nresult = split_string_into_characters(input_str)\nprint(result)  # Output: ['h', 'e', 'l', 'l', 'o']", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/565", "solution": "\ndef split_string_into_characters(s):\n    return list(s)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "print(is_even(4))  # Output: True\nprint(is_even(5))  # Output: False\nprint(is_even(0))  # Output: True\nprint(is_even(-2)) # Output: True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/600", "solution": "def is_even(n):\n    if not isinstance(n, int):\n        raise ValueError(\"Input must be an integer.\")\n    return n & 1 == 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "\ndef surface_area_square_pyramid(base_edge, slant_height):\n    base_area = base_edge ** 2\n    lateral_area = 4 * base_edge * slant_height\n    return base_area + lateral_area", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/581", "solution": "\ndef surface_area_square_pyramid(base_edge, slant_height):\n    base_area = base_edge ** 2\n    lateral_area = 4 * base_edge * slant_height\n    return base_area + lateral_area", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/581", "solution": "def surface_area_square_pyramid(base_edge, slant_height):\n    \"\"\"\n    Calculate the total surface area of a square pyramid.\n\n    Parameters:\n    base_edge (float): Length of one side of the square base.\n    slant_height (float): Height of each triangular face (slant height).\n\n    Returns:\n    float: Total surface area of the square pyramid.\n    \"\"\"\n    base_area = base_edge ** 2\n    lateral_area = 4 * base_edge * slant_height\n    return base_area + lateral_area", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/592", "solution": "def sum_product_binomial_coefficients(n):\n    \"\"\"\n    Returns the sum of all binomial coefficients for a given n.\n    This is equivalent to 2^n.\n    \"\"\"\n    return 2 ** n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "def find_dissimilar_elements(tuple1, tuple2):\n    \"\"\"\n    Find elements that are present in either of the two tuples but not in both.\n\n    Parameters:\n    tuple1 (tuple): First input tuple.\n    tuple2 (tuple): Second input tuple.\n\n    Returns:\n    list: A list of elements that are dissimilar between the two tuples.\n    \"\"\"\n    # Convert tuples to sets for efficient comparison\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Use symmetric difference to find dissimilar elements\n    dissimilar_elements = set1.symmetric_difference(set2)\n    \n    # Convert the result to a list and return\n    return list(dissimilar_elements)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/579", "solution": "def find_dissimilar_elements(tuple1, tuple2):\n    # Convert tuples to sets\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Find elements in either set but not in both\n    dissimilar_elements = set1.symmetric_difference(set2)\n    \n    # Return as a list\n    return list(dissimilar_elements)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/579", "solution": "\ndef find_dissimilar_elements(tuple1, tuple2):\n    # Convert tuples to sets for efficient comparison\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Find elements present in one set but not in the other\n    dissimilar_elements = set1.symmetric_difference(set2)\n    \n    return list(dissimilar_elements)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/589", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "\ndef max_subarray_sum(arr):\n    # Initialize current sum and max sum to the first element\n    current_sum = max_sum = arr[0]\n    \n    for num in arr[1:]:\n        # Update current sum to be the maximum of the current number or current sum plus the current number\n        current_sum = max(num, current_sum + num)\n        # Update max sum to be the maximum of the current max sum or the current sum\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/559", "solution": "\ndef max_subarray_sum(arr):\n    # Initialize current sum and max sum to the first element\n    current_sum = max_sum = arr[0]\n    \n    for num in arr[1:]:\n        # Update current sum to be the maximum of the current number or current sum plus the current number\n        current_sum = max(num, current_sum + num)\n        # Update max sum to be the maximum of the current max sum or the current sum\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/559", "solution": "\ndef max_subarray_sum(arr):\n    # Initialize current sum and max sum to the first element\n    current_sum = max_sum = arr[0]\n    \n    # Iterate through the array starting from the second element\n    for num in arr[1:]:\n        # Update current sum: either add current number or start new subarray from current number\n        current_sum = max(num, current_sum + num)\n        # Update max sum if current sum is larger\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "\ndef list_to_tuple(lst):\n    return tuple(lst)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/587", "solution": "my_list = [1, 2, 3, 4]\nmy_tuple = list_to_tuple(my_list)\nprint(my_tuple)  # Output: (1, 2, 3, 4)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/587", "solution": "my_list = [1, 2, 3, 4, 5]\nmy_tuple = list_to_tuple(my_list)\nprint(my_tuple)  # Output: (1, 2, 3, 4, 5)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "def split_and_add_end(arr, k):\n    \"\"\"\n    Splits the array into two parts and appends the first part to the end of the second part.\n\n    Parameters:\n    arr (list): The input list to be split and modified.\n    k (int): The number of elements to take from the beginning of the list.\n\n    Returns:\n    list: A new list where the first `k` elements are moved to the end.\n\n    Example:\n    >>> split_and_add_end([1, 2, 3, 4, 5], 2)\n    [3, 4, 5, 1, 2]\n    \"\"\"\n    # Handle edge cases\n    if not arr or k == 0:\n        return arr  # Return the original array if it's empty or k is 0\n\n    # Ensure k is within the bounds of the array\n    k = min(k, len(arr))\n\n    # Split the array into two parts\n    first_part = arr[:k]\n    second_part = arr[k:]\n\n    # Concatenate the second part with the first part\n    return second_part + first_part", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/586", "solution": "def split_and_add(arr, k):\n    \"\"\"\n    Rotates the array such that the first `k` elements are moved to the end.\n\n    Parameters:\n    arr (list): The input list to be rotated.\n    k (int): The number of elements to move from the beginning to the end.\n\n    Returns:\n    list: A new list with the first `k` elements moved to the end.\n\n    Example:\n    >>> split_and_add([1, 2, 3, 4, 5], 2)\n    [3, 4, 5, 1, 2]\n    \"\"\"\n    # Handle edge cases\n    if k < 0 or k >= len(arr):\n        return arr  # Return original array if k is invalid\n\n    # Split the array into two parts\n    first_part = arr[:k]\n    second_part = arr[k:]\n\n    # Concatenate the second part with the first part\n    return second_part + first_part", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/586", "solution": "def split_and_add(arr, k):\n    \"\"\"\n    Rotates the array such that the first `k` elements are moved to the end.\n\n    Parameters:\n    arr (list): The input list to be rotated.\n    k (int): The number of elements to move from the beginning to the end.\n\n    Returns:\n    list: A new list with the first `k` elements moved to the end.\n\n    Example:\n    >>> split_and_add([1, 2, 3, 4, 5], 2)\n    [3, 4, 5, 1, 2]\n    \"\"\"\n    # Handle edge cases\n    if k < 0 or k >= len(arr):\n        return arr  # Return original array if k is invalid\n\n    # Split the array into two parts\n    first_part = arr[:k]\n    second_part = arr[k:]\n\n    # Concatenate the second part with the first part\n    return second_part + first_part", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "\ndef remove_duplicates_from_lists(lists):\n    # Create a set to keep track of seen numbers\n    seen = set()\n    # Create a new list to store the result\n    result = []\n    for lst in lists:\n        # Iterate through each number in the current list\n        for num in lst:\n            # If the number hasn't been seen before, add it to the result and mark as seen\n            if num not in seen:\n                seen.add(num)\n                result.append(num)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/572", "solution": "\ndef remove_duplicates_from_lists(lists):\n    # Create a set to keep track of seen numbers\n    seen = set()\n    # Create a new list to store the result\n    result = []\n    for lst in lists:\n        # Iterate through each number in the current list\n        for num in lst:\n            # If the number hasn't been seen before, add it to the result and mark as seen\n            if num not in seen:\n                seen.add(num)\n                result.append(num)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}, {"task_id": "Mbpp/572", "solution": "\ndef remove_duplicates_from_lists(lists):\n    # Create a set to keep track of elements we've seen\n    seen = set()\n    # Create a new list to store the result\n    result = []\n    for lst in lists:\n        # Iterate through each element in the current list\n        new_lst = []\n        for num in lst:\n            if num not in seen:\n                # If the number hasn't been seen before, add it to the result\n                seen.add(num)\n                new_lst.append(num)\n            else:\n                # If it's a duplicate, skip it\n                pass\n        # Add the processed list to the result\n        result.append(new_lst)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}]}, "pass_at_k": {"base": {"pass@1": 0.05416666666666666}, "plus": {"pass@1": 0.04791666666666666}}}