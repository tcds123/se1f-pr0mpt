{"date": "2025-12-15 19:28", "hash": "ee43ecabebf20deef4bb776a405ac5b1", "eval": {"Mbpp/554": [{"task_id": "Mbpp/554", "solution": "\ndef find_odd_numbers(mixed_list):\n    return [num for num in mixed_list if num % 2 != 0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "def count_unequal_pairs(arr):\n    n = len(arr)\n    if n < 2:\n        return 0  # Not enough elements to form a pair\n\n    # Total number of possible pairs\n    total_pairs = n * (n - 1) // 2\n\n    # Frequency dictionary\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Count equal pairs\n    equal_pairs = 0\n    for count in freq.values():\n        equal_pairs += count * (count - 1) // 2\n\n    # Subtract equal pairs from total to get unequal pairs\n    return total_pairs - equal_pairs", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "import heapq", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "def rotate_array(arr, k):\n    \"\"\"\n    Rotates the array such that the first k elements are moved to the end.\n\n    Parameters:\n    arr (list): The input list to be rotated.\n    k (int): The number of elements to rotate from the start to the end.\n\n    Returns:\n    list: A new list with the first k elements moved to the end.\n    \"\"\"\n    # Handle edge cases\n    if not arr or k < 0 or k >= len(arr):\n        return arr  # Return original array if k is invalid\n\n    # Normalize k to be within the bounds of the array\n    k = k % len(arr)\n\n    # Split the array into two parts\n    first_part = arr[:k]\n    second_part = arr[k:]\n\n    # Concatenate the second part with the first part\n    return second_part + first_part", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "\ndef max_subarray_sum(arr):\n    # Initialize current sum and max sum to the first element\n    current_sum = max_sum = arr[0]\n    \n    for num in arr[1:]:\n        # Update current sum to be the maximum of the current number or current sum plus the current number\n        current_sum = max(num, current_sum + num)\n        # Update max sum to be the maximum of the current max sum or the current sum\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "def find_difference(arr):\n    \"\"\"\n    Calculate the difference between the largest and smallest values in a given array.\n    \n    Parameters:\n    arr (list): A list of numerical values.\n    \n    Returns:\n    int or float: The difference between the maximum and minimum values.\n    \n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array is empty.\")\n    \n    return max(arr) - min(arr)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "def extract_even_elements(nested_tuple):\n    \"\"\"\n    Extracts all even integers from a nested mixed tuple.\n\n    Parameters:\n    nested_tuple (tuple): A nested tuple containing integers and possibly other tuples.\n\n    Returns:\n    list: A list of even integers found in the nested tuple.\n    \"\"\"\n    even_elements = []\n\n    for element in nested_tuple:\n        # If the element is an integer and even, add it to the result\n        if isinstance(element, int) and element % 2 == 0:\n            even_elements.append(element)\n        # If the element is a tuple, recursively process it\n        elif isinstance(element, tuple):\n            even_elements.extend(extract_even_elements(element))\n    \n    return even_elements", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "def create_empty_dict_list(n):\n    \"\"\"\n    Create a list of `n` empty dictionaries.\n\n    Parameters:\n    n (int): The number of empty dictionaries to create.\n\n    Returns:\n    list: A list containing `n` empty dictionaries.\n    \"\"\"\n    return [{} for _ in range(n)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "def extract_values(s):\n    \"\"\"\n    Extracts all substrings that are enclosed within double quotation marks from a given string.\n    \n    Parameters:\n    s (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings, each representing a value found between double quotation marks.\n    \n    Example:\n    >>> extract_values(\"Hello \\\"world\\\" how are you \\\"doing\\\"?\")\n    ['world', 'doing']\n    \"\"\"\n    # Split the string by double quotes and filter out any empty strings\n    return [part for part in s.split('\"') if part.strip()]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["\"Python\", \"PHP\", \"Java\""]], "plus_fail_tests": [["This is a test input."]]}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "def is_subarray(sub_arr, main_arr):\n    \"\"\"\n    Check if sub_arr is a subarray of main_arr.\n    \n    Parameters:\n    sub_arr (list): The subarray to search for.\n    main_arr (list): The main array to search within.\n    \n    Returns:\n    bool: True if sub_arr is a subarray of main_arr, False otherwise.\n    \"\"\"\n    # Handle edge cases\n    if not sub_arr:\n        return True  # An empty array is a subarray of any array\n    if not main_arr:\n        return False  # An empty main array cannot contain a non-empty subarray\n    \n    len_sub = len(sub_arr)\n    len_main = len(main_arr)\n    \n    # Iterate through all possible starting positions in main_arr\n    for i in range(len_main - len_sub + 1):\n        # Check if the subarray matches starting at index i\n        if main_arr[i:i+len_sub] == sub_arr:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "\ndef remove_duplicates_from_lists(lists):\n    # Create a set to keep track of elements we've seen\n    seen = set()\n    # Create a new list to store the result\n    result = []\n    for lst in lists:\n        # Iterate through each element in the current list\n        new_lst = []\n        for num in lst:\n            if num not in seen:\n                # If the number hasn't been seen before, add it to the result\n                seen.add(num)\n                new_lst.append(num)\n            else:\n                # If it's a duplicate, skip it\n                pass\n        # Add the processed list to the result\n        result.append(new_lst)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "\ndef last_digit_factorial(n):\n    # Handle the special case where n is 0 or 1\n    if n == 0 or n == 1:\n        return 0\n    \n    # For numbers >= 5, the last digit of factorial is 0 because 5! = 120 and any higher factorial includes 5*2=10\n    if n >= 5:\n        return 0\n    \n    # Calculate the factorial and return the last digit\n    result = 1\n    for i in range(2, n+1):\n        result = (result * i) % 10\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "my_list = [1, 2, 3, 4]\nmy_tuple = list_to_tuple(my_list)\nprint(my_tuple)  # Output: (1, 2, 3, 4)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "def find_dissimilar_elements(tuple1, tuple2):\n    # Convert tuples to sets to remove duplicates and enable set operations\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Use symmetric difference to find dissimilar elements\n    dissimilar_elements = set1.symmetric_difference(set2)\n    \n    # Return the result as a list\n    return list(dissimilar_elements)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "def is_sorted(lst):\n    \"\"\"\n    Check if a list is sorted in ascending order.\n\n    Parameters:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if the list is sorted in ascending order, False otherwise.\n    \"\"\"\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "def max_sublist_length(lists):\n    \"\"\"\n    Find the maximum length of a sublist in a list of lists.\n\n    Parameters:\n    lists (list of list): A list containing multiple sublists.\n\n    Returns:\n    int: The length of the longest sublist.\n    \"\"\"\n    max_len = 0\n    for sublist in lists:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n    return max_len", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "\ndef digit_distance(num1, num2):\n    # Convert the numbers to strings to iterate over each digit\n    str_num1 = str(num1)\n    str_num2 = str(num2)\n    \n    # Check if the numbers have the same length\n    if len(str_num1) != len(str_num2):\n        return -1  # Return -1 if the numbers have different lengths\n    \n    # Calculate the digit distance by summing the absolute differences of each corresponding digit\n    distance = 0\n    for d1, d2 in zip(str_num1, str_num2):\n        distance += abs(int(d1) - int(d2))\n    \n    return distance", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "\ndef count_odd_xor_pairs(arr):\n    # Count the number of even and odd numbers in the array\n    even_count = 0\n    odd_count = 0\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The number of pairs with XOR as odd is even_count * odd_count\n    return even_count * odd_count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "\ndef surface_area_square_pyramid(base_edge, slant_height):\n    \"\"\"\n    Calculate the surface area of a square pyramid.\n    \n    Parameters:\n    base_edge (float): The length of the base edge of the pyramid.\n    slant_height (float): The slant height of the pyramid.\n    \n    Returns:\n    float: The total surface area of the pyramid.\n    \"\"\"\n    # Calculate the area of the square base\n    base_area = base_edge ** 2\n    \n    # Calculate the area of the four triangular faces\n    # Each triangle has base 'base_edge' and height 'slant_height'\n    # Since there are four triangles, multiply by 4\n    lateral_area = 4 * (base_edge * slant_height) / 2\n    \n    # Total surface area is the sum of base area and lateral area\n    total_surface_area = base_area + lateral_area\n    \n    return total_surface_area", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "def toggle_case(s):\n    \"\"\"\n    Toggles the case of each character in the input string.\n    \n    Parameters:\n    s (str): The input string whose characters' cases will be toggled.\n    \n    Returns:\n    str: A new string where each uppercase character becomes lowercase and vice versa.\n    \n    Example:\n    >>> toggle_case(\"Hello, World!\")\n    'hELLO, wORLD!'\n    \"\"\"\n    return s.swapcase()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "def union_of_tuples(t1, t2):\n    # Convert tuples to sets to remove duplicates\n    set1 = set(t1)\n    set2 = set(t2)\n    \n    # Compute the union of the two sets\n    union_set = set1.union(set2)\n    \n    # Convert the union set back to a tuple\n    return tuple(union_set)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "def sort_sublists(input_list):\n    \"\"\"\n    Sorts each sublist of strings in the given list of lists in place.\n\n    Parameters:\n    input_list (list of list of str): A list where each element is a list of strings.\n\n    Returns:\n    list of list of str: The input list with each sublist sorted in ascending order.\n    \"\"\"\n    for sublist in input_list:\n        sublist.sort()\n    return input_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "def difference_of_cubes_and_sum(n):\n    \"\"\"\n    Calculate the difference between the sum of cubes of the first n natural numbers\n    and the sum of the first n natural numbers.\n\n    Parameters:\n    n (int): A positive integer representing the number of natural numbers to consider.\n\n    Returns:\n    int: The difference between the sum of cubes and the sum of the first n natural numbers.\n    \"\"\"\n    # Calculate sum of cubes of first n natural numbers\n    sum_cubes = sum(i ** 3 for i in range(1, n + 1))\n    \n    # Calculate sum of first n natural numbers\n    sum_numbers = sum(range(1, n + 1))\n    \n    # Return the difference\n    return sum_cubes - sum_numbers", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "\ndef catalan(n):\n    # Using dynamic programming to compute the nth Catalan number\n    # Initialize a list to store intermediate results\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    \n    return catalan[n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "\ndef product_of_unique_numbers(lst):\n    # Create a frequency dictionary to count occurrences of each number\n    frequency = {}\n    for num in lst:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] += 1\n    \n    # Filter numbers that appear exactly once\n    unique_numbers = [num for num in lst if frequency[num] == 1]\n    \n    # Calculate the product of the unique numbers\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    \n    return product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "input_str = \"hello\"\nresult = split_string_into_characters(input_str)\nprint(result)  # Output: ['h', 'e', 'l', 'l', 'o']", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    \"\"\"\n    Calculate the sum of the digits of a non-negative integer.\n\n    Parameters:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The sum of the digits of the input number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    total = 0\n    while n > 0:\n        total += n % 10\n        n = n // 10\n    return total", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2):\n    \"\"\"\n    Interleaves two lists of the same length by alternating elements from each list.\n\n    Parameters:\n    - list1: First list of elements.\n    - list2: Second list of elements.\n\n    Returns:\n    - A new list where elements from list1 and list2 are interleaved.\n\n    Raises:\n    - ValueError: If the input lists are not of the same length.\n\n    Example:\n    >>> interleave_lists([1, 2, 3], [4, 5, 6])\n    [1, 4, 2, 5, 3, 6]\n    \"\"\"\n    # Check if the lists are of the same length\n    if len(list1) != len(list2):\n        raise ValueError(\"Lists must be of the same length\")\n\n    # Interleave the elements from both lists\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n\n    return interleaved", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]]], "plus_fail_tests": [[[], [], []]]}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "def kth_element_binary_search(arr1, arr2, k):\n    # Handle edge cases\n    if not arr1:\n        return arr2[k - 1]\n    if not arr2:\n        return arr1[k - 1]\n    \n    # Ensure arr1 is the shorter array to optimize the binary search\n    if len(arr1) > len(arr2):\n        arr1, arr2 = arr2, arr1\n    \n    # Initialize binary search boundaries\n    low, high = 0, len(arr1)\n    \n    while low <= high:\n        # Partition the first array\n        mid = (low + high) // 2\n        # Partition the second array\n        partition2 = k - mid\n        \n        # Get the elements at the partition points\n        a1 = arr1[mid - 1] if mid > 0 else -float('inf')\n        a2 = arr2[partition2 - 1] if partition2 > 0 else -float('inf')\n        b1 = arr1[mid] if mid < len(arr1) else float('inf')\n        b2 = arr2[partition2] if partition2 < len(arr2) else float('inf')\n        \n        # Check if we've found the kth element\n        if a1 > b2 and a2 > b1:\n            return min(a1, a2)\n        elif a1 > b1:\n            # Move the partition in arr1 to the left\n            high = mid - 1\n        else:\n            # Move the partition in arr1 to the right\n            low = mid + 1\n    \n    # If we exit the loop without returning, k is out of bounds\n    return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "\ndef interchange_first_last(lst):\n    # Check if the list is not empty and has at least two elements\n    if len(lst) < 2:\n        return lst  # Return the original list if it's too short\n    \n    # Swap the first and last elements\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "\ndef perfect_squares_between(a, b):\n    # Handle the case where a > b\n    if a > b:\n        a, b = b, a\n    \n    # Find the smallest integer whose square is >= a\n    start = int(a ** 0.5)\n    if start ** 2 < a:\n        start += 1\n    \n    # Find the largest integer whose square is <= b\n    end = int(b ** 0.5)\n    \n    # If start > end, there are no perfect squares between a and b\n    if start > end:\n        return []\n    \n    # Generate the list of perfect squares between a and b\n    return [i**2 for i in range(start, end + 1)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "\ndef remove_leading_zeros(ip_address):\n    # Split the IP address into its four octets\n    octets = ip_address.split('.')\n    \n    # Process each octet to remove leading zeros\n    processed_octets = []\n    for octet in octets:\n        # Check if the octet is all zeros\n        if octet == '0':\n            processed_octets.append('0')\n        else:\n            # Remove leading zeros by converting to integer and back to string\n            processed_octets.append(str(int(octet)))\n    \n    # Join the processed octets back into an IP address\n    return '.'.join(processed_octets)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "print(is_even(4))   # True (4 is even)\nprint(is_even(5))   # False (5 is odd)\nprint(is_even(-2))  # True (-2 is even)\nprint(is_even(-3))  # False (-3 is odd)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "def tuple_size(input_tuple):\n    \"\"\"\n    Returns the size (number of elements) of the given tuple.\n    \n    Parameters:\n    input_tuple (tuple): The tuple whose size is to be determined.\n    \n    Returns:\n    int: The number of elements in the tuple.\n    \"\"\"\n    return len(input_tuple)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["A", 1, "B", 2, "C", 3]]], "plus_fail_tests": [[[[1, "Raju"], [2, "Nikhil"], [3, "Deepanshu"]]]]}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "def sum_and_average(n):\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    # Sum of first n natural numbers using the formula: n*(n+1)//2\n    total_sum = n * (n + 1) // 2\n    \n    # Average is sum divided by n\n    average = total_sum / n\n    \n    return total_sum, average", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "def is_armstrong(n):\n    \"\"\"\n    Check if a number is an Armstrong number (Narcissistic number).\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is an Armstrong number, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False  # Negative numbers are not considered\n\n    digits = str(n)\n    length = len(digits)\n    sum_of_powers = 0\n\n    for digit in digits:\n        sum_of_powers += int(digit) ** length\n\n    return sum_of_powers == n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "def difference_even_odd(nums):\n    even = []\n    odd = []\n    for num in nums:\n        if num % 2 == 0:\n            even.append(num)\n        else:\n            odd.append(num)\n    if not even or not odd:\n        raise ValueError(\"List must contain at least one even and one odd number.\")\n    return even[0] - odd[0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}]}, "pass_at_k": {"base": {"pass@1": 0.05128205128205128}, "plus": {"pass@1": 0.05128205128205128}}}