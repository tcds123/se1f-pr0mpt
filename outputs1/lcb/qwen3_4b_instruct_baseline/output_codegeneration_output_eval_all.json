[
    {
        "question_title": "Overall Winner",
        "question_content": "Takahashi and Aoki played N games.\r\nYou are given a string S of length N, representing the results of these games.\r\nTakahashi won the i-th game if the i-th character of S is T, and Aoki won that game if it is A.\nThe overall winner between Takahashi and Aoki is the one who won more games than the other.\r\nIf they had the same number of wins, the overall winner is the one who reached that number of wins first.\r\nFind the overall winner: Takahashi or Aoki.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN\r\nS\n\nOutput\n\nIf the overall winner is Takahashi, print T; if it is Aoki, print A.\n\nConstraints\n\n\n- 1\\leq N \\leq 100\n- N is an integer.\n- S is a string of length N consisting of T and A.\n\nSample Input 1\n\n5\r\nTTAAT\n\nSample Output 1\n\nT\r\n\nTakahashi won three games, and Aoki won two.\r\nThus, the overall winner is Takahashi, who won more games.\n\nSample Input 2\n\n6\r\nATTATA\n\nSample Output 2\n\nT\r\n\nBoth Takahashi and Aoki won three games.\r\nTakahashi reached three wins in the fifth game, and Aoki in the sixth game.\r\nThus, the overall winner is Takahashi, who reached three wins first.\n\nSample Input 3\n\n1\r\nA\n\nSample Output 3\n\nA",
        "platform": "atcoder",
        "question_id": "abc301_a",
        "contest_id": "abc301",
        "contest_date": "2023-05-13T00:00:00",
        "starter_code": "",
        "difficulty": "easy",
        "output_list": [
            "n = int(input())\ns = input().strip()\n\ntakahashi_wins = 0\naoki_wins = 0\ntakahashi_reached = 0\naoki_reached = 0\n\nfor i in range(n):\n    if s[i] == 'T':\n        takahashi_wins += 1\n    else:\n        aoki_wins += 1\n    \n    # Check if either player has reached the number of wins\n    if takahashi_wins > aoki_wins:\n        print('T')\n        exit()\n    elif aoki_wins > takahashi_wins:\n        print('A')\n        exit()\n    \n    # If they are tied, check who reached this tie point first\n    if takahashi_wins == aoki_wins and takahashi_reached == 0 and aoki_reached == 0:\n        # This is the first time they are tied\n        takahashi_reached = i + 1\n        aoki_reached = i + 1\n    elif takahashi_wins == aoki_wins:\n        # They are tied again, but we only care about the first time\n        # So we don't update the reached values\n        pass\n\n# If we reach here, they have the same number of wins and we need to compare\n# who reached that number first\nif takahashi_wins == aoki_wins:\n    if takahashi_reached < aoki_reached:\n        print('T')\n    else:\n        print('A')\nelse:\n    # One player has more wins, so we already printed the result above\n    pass"
        ],
        "code_list": [
            "n = int(input())\ns = input().strip()\n\ntakahashi_wins = 0\naoki_wins = 0\ntakahashi_reached = 0\naoki_reached = 0\n\nfor i in range(n):\n    if s[i] == 'T':\n        takahashi_wins += 1\n    else:\n        aoki_wins += 1\n    \n    # Check if either player has reached the number of wins\n    if takahashi_wins > aoki_wins:\n        print('T')\n        exit()\n    elif aoki_wins > takahashi_wins:\n        print('A')\n        exit()\n    \n    # If they are tied, check who reached this tie point first\n    if takahashi_wins == aoki_wins and takahashi_reached == 0 and aoki_reached == 0:\n        # This is the first time they are tied\n        takahashi_reached = i + 1\n        aoki_reached = i + 1\n    elif takahashi_wins == aoki_wins:\n        # They are tied again, but we only care about the first time\n        # So we don't update the reached values\n        pass\n\n# If we reach here, they have the same number of wins and we need to compare\n# who reached that number first\nif takahashi_wins == aoki_wins:\n    if takahashi_reached < aoki_reached:\n        print('T')\n    else:\n        print('A')\nelse:\n    # One player has more wins, so we already printed the result above\n    pass"
        ],
        "graded_list": [
            false
        ],
        "pass@1": 0.0,
        "metadata": [
            "{\"output\": \"A\\n\", \"inputs\": \"6\\nATTATA\\n\", \"expected\": \"T\\n\", \"error_code\": -2, \"error_message\": \"Wrong answer at output_line_idx=0: A != T\"}"
        ]
    },
    {
        "question_title": "Fill the Gaps",
        "question_content": "We have a sequence of length N consisting of positive integers: A=(A_1,\\ldots,A_N). Any two adjacent terms have different values.\nLet us insert some numbers into this sequence by the following procedure.\n\n- If every pair of adjacent terms in A has an absolute difference of 1, terminate the procedure.\n- Let A_i, A_{i+1} be the pair of adjacent terms nearest to the beginning of A whose absolute difference is not 1.\n- If A_i < A_{i+1}, insert A_i+1,A_i+2,\\ldots,A_{i+1}-1 between A_i and A_{i+1}.\n- If A_i > A_{i+1}, insert A_i-1,A_i-2,\\ldots,A_{i+1}+1 between A_i and A_{i+1}.\n\n\n- Return to step 1.\n\nPrint the sequence when the procedure ends.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN\r\nA_1 A_2 \\ldots A_N\n\nOutput\n\nPrint the terms in the sequence when the procedure ends, separated by spaces.\n\nConstraints\n\n\n- 2 \\leq N \\leq 100\n- 1 \\leq A_i \\leq 100\n- A_i \\neq A_{i+1}\n- All values in the input are integers.\n\nSample Input 1\n\n4\r\n2 5 1 2\n\nSample Output 1\n\n2 3 4 5 4 3 2 1 2\r\n\nThe initial sequence is (2,5,1,2). The procedure goes as follows.\n\n- Insert 3,4 between the first term 2 and the second term 5, making the sequence (2,3,4,5,1,2).\n- Insert 4,3,2 between the fourth term 5 and the fifth term 1, making the sequence (2,3,4,5,4,3,2,1,2).\n\nSample Input 2\n\n6\r\n3 4 5 6 5 4\n\nSample Output 2\n\n3 4 5 6 5 4\r\n\nNo insertions may be performed.",
        "platform": "atcoder",
        "question_id": "abc301_b",
        "contest_id": "abc301",
        "contest_date": "2023-05-13T00:00:00",
        "starter_code": "",
        "difficulty": "easy",
        "output_list": [
            "n = int(input())\na = list(map(int, input().split()))\n\nwhile True:\n    found = False\n    for i in range(len(a) - 1):\n        if abs(a[i] - a[i+1]) != 1:\n            found = True\n            if a[i] < a[i+1]:\n                # Insert values from a[i]+1 to a[i+1]-1\n                insert_values = list(range(a[i] + 1, a[i+1]))\n                a[i+1: i+1] = insert_values\n            else:\n                # Insert values from a[i]-1 down to a[i+1]+1\n                insert_values = list(range(a[i] - 1, a[i+1], -1))\n                a[i+1: i+1] = insert_values\n            break\n    if not found:\n        break\n\nprint(' '.join(map(str, a)))"
        ],
        "code_list": [
            "n = int(input())\na = list(map(int, input().split()))\n\nwhile True:\n    found = False\n    for i in range(len(a) - 1):\n        if abs(a[i] - a[i+1]) != 1:\n            found = True\n            if a[i] < a[i+1]:\n                # Insert values from a[i]+1 to a[i+1]-1\n                insert_values = list(range(a[i] + 1, a[i+1]))\n                a[i+1: i+1] = insert_values\n            else:\n                # Insert values from a[i]-1 down to a[i+1]+1\n                insert_values = list(range(a[i] - 1, a[i+1], -1))\n                a[i+1: i+1] = insert_values\n            break\n    if not found:\n        break\n\nprint(' '.join(map(str, a)))"
        ],
        "graded_list": [
            true
        ],
        "pass@1": 1.0,
        "metadata": [
            "{\"execution time\": 0.1356062889099121}"
        ]
    },
    {
        "question_title": "AtCoder Cards",
        "question_content": "A single-player card game is popular in AtCoder Inc.\r\nEach card in the game has a lowercase English letter or the symbol @ written on it. There is plenty number of cards for each kind.\r\nThe game goes as follows.\n\n- Arrange the same number of cards in two rows.\n- Replace each card with @ with one of the following cards: a, t, c, o, d, e, r.\n- If the two rows of cards coincide, you win. Otherwise, you lose.\n\nTo win this game, you will do the following cheat.\n\n- Freely rearrange the cards within a row whenever you want after step 1.\n\nYou are given two strings S and T, representing the two rows you have after step 1. Determine whether it is possible to win with cheating allowed.\n\nInput\n\nThe input is given from Standard Input in the following format:\nS\r\nT\n\nOutput\n\nIf it is possible to win with cheating allowed, print Yes; otherwise, print No.\n\nConstraints\n\n\n- S and T consist of lowercase English letters and @.\n- The lengths of S and T are equal and between 1 and 2\\times 10^5, inclusive.\n\nSample Input 1\n\nch@ku@ai\r\nchoku@@i\n\nSample Output 1\n\nYes\r\n\nYou can replace the @s so that both rows become chokudai.\n\nSample Input 2\n\nch@kud@i\r\nakidu@ho\n\nSample Output 2\n\nYes\r\n\nYou can cheat and replace the @s so that both rows become chokudai.\n\nSample Input 3\n\naoki\r\n@ok@\n\nSample Output 3\n\nNo\r\n\nYou cannot win even with cheating.\n\nSample Input 4\n\naa\r\nbb\n\nSample Output 4\n\nNo",
        "platform": "atcoder",
        "question_id": "abc301_c",
        "contest_id": "abc301",
        "contest_date": "2023-05-13T00:00:00",
        "starter_code": "",
        "difficulty": "medium",
        "output_list": [
            "S = input().strip()\nT = input().strip()\nn = len(S)\n\n# Count the frequency of each character in S and T\nfrom collections import Counter\ns_count = Counter(S)\nt_count = Counter(T)\n\n# Count the number of @ symbols in each string\nat_s = s_count['@']\nat_t = t_count['@']\n\n# The total number of @ symbols is at_s + at_t\n# We can replace each @ with any of the letters a, t, c, o, d, e, r\n# So, we can use the @ symbols to \"fill in\" the missing letters in both strings\n\n# For each letter in the set {'a', 't', 'c', 'o', 'd', 'e', 'r'}, \n# if the count in S is less than in T, we need to use @ to make up the difference\n# Similarly, if the count in T is less than in S, we need to use @ to make up the difference\n\n# But we can only use @ symbols to fill in the missing letters\n# So, the total number of @ symbols must be at least the sum of the deficits for letters in {'a', 't', 'c', 'o', 'd', 'e', 'r'}\n\n# Calculate the deficit for each letter in the special set\nspecial = set('atcoder')\ntotal_deficit = 0\n\nfor char in special:\n    deficit_s = max(0, t_count[char] - s_count[char])\n    deficit_t = max(0, s_count[char] - t_count[char])\n    total_deficit += deficit_s + deficit_t\n\n# If the total deficit is greater than the total number of @ symbols, it's impossible\nif total_deficit > at_s + at_t:\n    print(\"No\")\nelse:\n    print(\"Yes\")"
        ],
        "code_list": [
            "S = input().strip()\nT = input().strip()\nn = len(S)\n\n# Count the frequency of each character in S and T\nfrom collections import Counter\ns_count = Counter(S)\nt_count = Counter(T)\n\n# Count the number of @ symbols in each string\nat_s = s_count['@']\nat_t = t_count['@']\n\n# The total number of @ symbols is at_s + at_t\n# We can replace each @ with any of the letters a, t, c, o, d, e, r\n# So, we can use the @ symbols to \"fill in\" the missing letters in both strings\n\n# For each letter in the set {'a', 't', 'c', 'o', 'd', 'e', 'r'}, \n# if the count in S is less than in T, we need to use @ to make up the difference\n# Similarly, if the count in T is less than in S, we need to use @ to make up the difference\n\n# But we can only use @ symbols to fill in the missing letters\n# So, the total number of @ symbols must be at least the sum of the deficits for letters in {'a', 't', 'c', 'o', 'd', 'e', 'r'}\n\n# Calculate the deficit for each letter in the special set\nspecial = set('atcoder')\ntotal_deficit = 0\n\nfor char in special:\n    deficit_s = max(0, t_count[char] - s_count[char])\n    deficit_t = max(0, s_count[char] - t_count[char])\n    total_deficit += deficit_s + deficit_t\n\n# If the total deficit is greater than the total number of @ symbols, it's impossible\nif total_deficit > at_s + at_t:\n    print(\"No\")\nelse:\n    print(\"Yes\")"
        ],
        "graded_list": [
            false
        ],
        "pass@1": 0.0,
        "metadata": [
            "{\"output\": \"Yes\\n\", \"inputs\": \"aoki\\n@ok@\\n\", \"expected\": \"No\\n\", \"error_code\": -2, \"error_message\": \"Wrong answer at output_line_idx=0: Yes != No\"}"
        ]
    },
    {
        "question_title": "Bitmask",
        "question_content": "You are given an integer N and a string S consisting of 0, 1, and ?.\nLet T be the set of values that can be obtained by replacing each ? in S with 0 or 1 and interpreting the result as a binary integer.\nFor instance, if S= ?0?, we have T=\\lbrace 000_{(2)},001_{(2)},100_{(2)},101_{(2)}\\rbrace=\\lbrace 0,1,4,5\\rbrace.\nPrint (as a decimal integer) the greatest value in T less than or equal to N.\nIf T does not contain a value less than or equal to N, print -1 instead.\n\nInput\n\nThe input is given from Standard Input in the following format:\nS\nN\n\nOutput\n\nPrint the answer.\n\nConstraints\n\n\n- S is a string consisting of 0, 1, and ?.\n- The length of S is between 1 and 60, inclusive.\n- 1\\leq N \\leq 10^{18}\n- N is an integer.\n\nSample Input 1\n\n?0?\n2\n\nSample Output 1\n\n1\n\nAs shown in the problem statement, T=\\lbrace 0,1,4,5\\rbrace.\nAmong them, 0 and 1 are less than or equal to N, so you should print the greatest of them, 1.\n\nSample Input 2\n\n101\n4\n\nSample Output 2\n\n-1\n\nWe have T=\\lbrace 5\\rbrace, which does not contain a value less than or equal to N.\n\nSample Input 3\n\n?0?\n1000000000000000000\n\nSample Output 3\n\n5",
        "platform": "atcoder",
        "question_id": "abc301_d",
        "contest_id": "abc301",
        "contest_date": "2023-05-13T00:00:00",
        "starter_code": "",
        "difficulty": "medium",
        "output_list": [
            "def solve():\n    S = input().strip()\n    N = int(input().strip())\n    \n    # If the string has no ? characters, we have only one possible value\n    if '?' not in S:\n        val = int(S, 2)\n        if val <= N:\n            return val\n        else:\n            return -1\n    \n    # We want to find the maximum value in T that is <= N\n    # We can use a greedy approach: try to set each ? to 1 if possible,\n    # but if setting it to 1 would exceed N, then set it to 0.\n    \n    # Convert S to a list of characters for easier manipulation\n    chars = list(S)\n    n = len(chars)\n    \n    # We'll build the result string from left to right\n    # We need to consider the impact of each bit on the final value\n    \n    # First, we try to maximize the value without exceeding N\n    # We can use a greedy strategy: for each position, try to set it to 1 if possible\n    # But we need to be careful about the remaining positions\n    \n    # Let's try to build the result from left to right\n    # We'll keep track of the current value and the remaining positions\n    \n    # We can use a different approach: try to set each ? to 1, but if that would make the value exceed N,\n    # then we set it to 0. However, we need to consider the effect of the remaining bits.\n    \n    # We can use a greedy algorithm with backtracking or dynamic programming,\n    # but given the constraints (length up to 60), we can try a greedy approach.\n    \n    # Actually, we can use a greedy approach: from left to right, for each ?, \n    # we try to set it to 1, and see if the resulting value can still be <= N.\n    # But we need to account for the maximum possible value of the suffix.\n    \n    # For each position i, if we set the bit to 1, the maximum value we can get from the suffix is:\n    # (2^(n-1-i)) + (2^(n-2-i)) + ... + 2^0 = 2^(n-i) - 1\n    # But actually, we need to consider the current value and the remaining bits.\n    \n    # Let's define a function to compute the maximum possible value from a given suffix\n    def max_suffix(pos):\n        # pos is the current position (0-indexed)\n        # returns the maximum value that can be formed from the suffix starting at pos\n        suffix_len = n - pos\n        return (1 << suffix_len) - 1\n    \n    # We'll build the result string\n    result = []\n    current_val = 0\n    \n    # We'll go from left to right\n    for i in range(n):\n        if chars[i] == '0':\n            result.append('0')\n            current_val = current_val * 2\n            current_val += 0\n        elif chars[i] == '1':\n            result.append('1')\n            current_val = current_val * 2\n            current_val += 1\n        else:  # chars[i] == '?'\n            # We need to decide whether to set it to 0 or 1\n            # If we set it to 1, the value becomes current_val * 2 + 1\n            # The maximum possible value from the remaining bits is max_suffix(i+1)\n            # So the total value would be current_val * 2 + 1 + (max_suffix(i+1))\n            # But we need to check if this exceeds N\n            \n            # The maximum value we can get from the suffix is max_suffix(i+1)\n            # So if we set this bit to 1, the total value would be:\n            # current_val * 2 + 1 + max_suffix(i+1)\n            # But actually, we can only get up to current_val * 2 + 1 + max_suffix(i+1)\n            \n            # However, we are building the value incrementally, so we can compute:\n            # If we set this bit to 1, the value becomes current_val * 2 + 1\n            # Then we can add up to max_suffix(i+1) from the remaining bits\n            # So the maximum value we can get if we set this bit to 1 is:\n            # current_val * 2 + 1 + max_suffix(i+1)\n            \n            # But we don't need to go that far. We just need to know if setting it to 1 is possible\n            # without exceeding N.\n            \n            # The maximum value we can get from the suffix is max_suffix(i+1)\n            # So if we set this bit to 1, the total value would be:\n            # current_val * 2 + 1 + (some value between 0 and max_suffix(i+1))\n            # So the maximum possible value if we set this bit to 1 is:\n            # current_val * 2 + 1 + max_suffix(i+1)\n            \n            # If this maximum value exceeds N, then we cannot set this bit to 1\n            # Otherwise, we can set it to 1 to maximize the value\n            \n            max_possible_with_1 = current_val * 2 + 1 + max_suffix(i+1)\n            if max_possible_with_1 <= N:\n                result.append('1')\n                current_val = current_val * 2 + 1\n            else:\n                result.append('0')\n                current_val = current_val * 2\n                \n    # Convert result to integer\n    final_val = int(''.join(result), 2)\n    \n    # But we need to check if this value is actually in T and <= N\n    # It is, by construction, because we never set a bit to 1 when it would exceed N\n    # However, we need to ensure that we are not missing a better value\n    \n    # Actually, the above greedy approach might not work because we are not considering\n    # that we might want to set a bit to 0 to allow for a larger value in the future,\n    # but in binary, higher bits have more weight, so setting a bit to 1 when possible\n    # is always better.\n    \n    # However, there's a flaw: when we set a bit to 1, we are assuming that we can\n    # get the maximum value from the suffix, but we are not actually constructing\n    # the maximum value. We are just checking if it's possible.\n    \n    # But in fact, if we can set a bit to 1 without exceeding N, then we should,\n    # because it increases the value, and we want the maximum value <= N.\n    \n    # However, consider: if setting a bit to 1 would make the value exceed N even in the best case,\n    # then we must set it to 0.\n    \n    # So the above logic is correct.\n    \n    # But we need to verify with the sample: S = \"?0?\", N = 2\n    # i=0: chars[0] = '?'\n    #   current_val = 0\n    #   max_possible_with_1 = 0*2 + 1 + max_suffix(1) = 1 + (2^2 - 1) = 1 + 3 = 4\n    #   4 > 2, so we set to 0\n    #   current_val = 0\n    # i=1: chars[1] = '0'\n    #   result.append('0'), current_val = 0\n    # i=2: chars[2] = '?'\n    #   max_possible_with_1 = 0*2 + 1 + max_suffix(3) = 1 + (2^1 - 1) = 1 + 1 = 2\n    #   2 <= 2, so we set to 1\n    #   current_val = 0*2 + 1 = 1\n    # Final value = 1, which is correct.\n    \n    # Another sample: S = \"101\", N = 4\n    # No ? characters, so we just compute val = 5, which is > 4, so return -1.\n    \n    # But what about S = \"?0?\", N = 1000000000000000000?\n    # We want to get 5.\n    \n    # Let's simulate:\n    # i=0: chars[0] = '?'\n    #   current_val = 0\n    #   max_possible_with_1 = 0*2 + 1 + max_suffix(1) = 1 + (2^2 - 1) = 1 + 3 = 4\n    #   4 <= 1000000000000000000, so set to 1\n    #   current_val = 1\n    # i=1: chars[1] = '0'\n    #   result.append('0'), current_val = 1*2 + 0 = 2\n    # i=2: chars[2] = '?'\n    #   max_possible_with_1 = 2*2 + 1 + max_suffix(3) = 5 + (2^1 - 1) = 5 + 1 = 6\n    #   6 <= 1000000000000000000, so set to 1\n    #   current_val ="
        ],
        "code_list": [
            "def solve():\n    S = input().strip()\n    N = int(input().strip())\n    \n    # If the string has no ? characters, we have only one possible value\n    if '?' not in S:\n        val = int(S, 2)\n        if val <= N:\n            return val\n        else:\n            return -1\n    \n    # We want to find the maximum value in T that is <= N\n    # We can use a greedy approach: try to set each ? to 1 if possible,\n    # but if setting it to 1 would exceed N, then set it to 0.\n    \n    # Convert S to a list of characters for easier manipulation\n    chars = list(S)\n    n = len(chars)\n    \n    # We'll build the result string from left to right\n    # We need to consider the impact of each bit on the final value\n    \n    # First, we try to maximize the value without exceeding N\n    # We can use a greedy strategy: for each position, try to set it to 1 if possible\n    # But we need to be careful about the remaining positions\n    \n    # Let's try to build the result from left to right\n    # We'll keep track of the current value and the remaining positions\n    \n    # We can use a different approach: try to set each ? to 1, but if that would make the value exceed N,\n    # then we set it to 0. However, we need to consider the effect of the remaining bits.\n    \n    # We can use a greedy algorithm with backtracking or dynamic programming,\n    # but given the constraints (length up to 60), we can try a greedy approach.\n    \n    # Actually, we can use a greedy approach: from left to right, for each ?, \n    # we try to set it to 1, and see if the resulting value can still be <= N.\n    # But we need to account for the maximum possible value of the suffix.\n    \n    # For each position i, if we set the bit to 1, the maximum value we can get from the suffix is:\n    # (2^(n-1-i)) + (2^(n-2-i)) + ... + 2^0 = 2^(n-i) - 1\n    # But actually, we need to consider the current value and the remaining bits.\n    \n    # Let's define a function to compute the maximum possible value from a given suffix\n    def max_suffix(pos):\n        # pos is the current position (0-indexed)\n        # returns the maximum value that can be formed from the suffix starting at pos\n        suffix_len = n - pos\n        return (1 << suffix_len) - 1\n    \n    # We'll build the result string\n    result = []\n    current_val = 0\n    \n    # We'll go from left to right\n    for i in range(n):\n        if chars[i] == '0':\n            result.append('0')\n            current_val = current_val * 2\n            current_val += 0\n        elif chars[i] == '1':\n            result.append('1')\n            current_val = current_val * 2\n            current_val += 1\n        else:  # chars[i] == '?'\n            # We need to decide whether to set it to 0 or 1\n            # If we set it to 1, the value becomes current_val * 2 + 1\n            # The maximum possible value from the remaining bits is max_suffix(i+1)\n            # So the total value would be current_val * 2 + 1 + (max_suffix(i+1))\n            # But we need to check if this exceeds N\n            \n            # The maximum value we can get from the suffix is max_suffix(i+1)\n            # So if we set this bit to 1, the total value would be:\n            # current_val * 2 + 1 + max_suffix(i+1)\n            # But actually, we can only get up to current_val * 2 + 1 + max_suffix(i+1)\n            \n            # However, we are building the value incrementally, so we can compute:\n            # If we set this bit to 1, the value becomes current_val * 2 + 1\n            # Then we can add up to max_suffix(i+1) from the remaining bits\n            # So the maximum value we can get if we set this bit to 1 is:\n            # current_val * 2 + 1 + max_suffix(i+1)\n            \n            # But we don't need to go that far. We just need to know if setting it to 1 is possible\n            # without exceeding N.\n            \n            # The maximum value we can get from the suffix is max_suffix(i+1)\n            # So if we set this bit to 1, the total value would be:\n            # current_val * 2 + 1 + (some value between 0 and max_suffix(i+1))\n            # So the maximum possible value if we set this bit to 1 is:\n            # current_val * 2 + 1 + max_suffix(i+1)\n            \n            # If this maximum value exceeds N, then we cannot set this bit to 1\n            # Otherwise, we can set it to 1 to maximize the value\n            \n            max_possible_with_1 = current_val * 2 + 1 + max_suffix(i+1)\n            if max_possible_with_1 <= N:\n                result.append('1')\n                current_val = current_val * 2 + 1\n            else:\n                result.append('0')\n                current_val = current_val * 2\n                \n    # Convert result to integer\n    final_val = int(''.join(result), 2)\n    \n    # But we need to check if this value is actually in T and <= N\n    # It is, by construction, because we never set a bit to 1 when it would exceed N\n    # However, we need to ensure that we are not missing a better value\n    \n    # Actually, the above greedy approach might not work because we are not considering\n    # that we might want to set a bit to 0 to allow for a larger value in the future,\n    # but in binary, higher bits have more weight, so setting a bit to 1 when possible\n    # is always better.\n    \n    # However, there's a flaw: when we set a bit to 1, we are assuming that we can\n    # get the maximum value from the suffix, but we are not actually constructing\n    # the maximum value. We are just checking if it's possible.\n    \n    # But in fact, if we can set a bit to 1 without exceeding N, then we should,\n    # because it increases the value, and we want the maximum value <= N.\n    \n    # However, consider: if setting a bit to 1 would make the value exceed N even in the best case,\n    # then we must set it to 0.\n    \n    # So the above logic is correct.\n    \n    # But we need to verify with the sample: S = \"?0?\", N = 2\n    # i=0: chars[0] = '?'\n    #   current_val = 0\n    #   max_possible_with_1 = 0*2 + 1 + max_suffix(1) = 1 + (2^2 - 1) = 1 + 3 = 4\n    #   4 > 2, so we set to 0\n    #   current_val = 0\n    # i=1: chars[1] = '0'\n    #   result.append('0'), current_val = 0\n    # i=2: chars[2] = '?'\n    #   max_possible_with_1 = 0*2 + 1 + max_suffix(3) = 1 + (2^1 - 1) = 1 + 1 = 2\n    #   2 <= 2, so we set to 1\n    #   current_val = 0*2 + 1 = 1\n    # Final value = 1, which is correct.\n    \n    # Another sample: S = \"101\", N = 4\n    # No ? characters, so we just compute val = 5, which is > 4, so return -1.\n    \n    # But what about S = \"?0?\", N = 1000000000000000000?\n    # We want to get 5.\n    \n    # Let's simulate:\n    # i=0: chars[0] = '?'\n    #   current_val = 0\n    #   max_possible_with_1 = 0*2 + 1 + max_suffix(1) = 1 + (2^2 - 1) = 1 + 3 = 4\n    #   4 <= 1000000000000000000, so set to 1\n    #   current_val = 1\n    # i=1: chars[1] = '0'\n    #   result.append('0'), current_val = 1*2 + 0 = 2\n    # i=2: chars[2] = '?'\n    #   max_possible_with_1 = 2*2 + 1 + max_suffix(3) = 5 + (2^1 - 1) = 5 + 1 = 6\n    #   6 <= 1000000000000000000, so set to 1\n    #   current_val ="
        ],
        "graded_list": [
            false
        ],
        "pass@1": 0.0,
        "metadata": [
            "{\"output\": \"\", \"inputs\": \"?0?\\n2\\n\", \"expected\": \"1\\n\", \"error_code\": -2, \"error_message\": \"Wrong answer at output_line_idx=0:  != 1\"}"
        ]
    },
    {
        "question_title": "Anti",
        "question_content": "A DDoS-type string is a string of length 4 consisting of uppercase and lowercase English letters satisfying both of the following conditions.\n\n- The first, second, and fourth characters are uppercase English letters, and the third character is a lowercase English letter.\n- The first and second characters are equal.\n\nFor instance, DDoS and AAaA are DDoS-type strings, while neither ddos nor IPoE is.\nYou are given a string S consisting of uppercase and lowercase English letters and ?.\nLet q be the number of occurrences of ? in S. There are 52^q strings that can be obtained by independently replacing each ? in S with an uppercase or lowercase English letter.\nAmong these strings, find the number of ones that do not contain a DDoS-type string as a subsequence, modulo 998244353.\n\nInput\n\nThe input is given from Standard Input in the following format:\nS\n\nOutput\n\nPrint the answer.\n\nConstraints\n\n\n- S consists of uppercase English letters, lowercase English letters, and ?.\n- The length of S is between 4 and 3\\times 10^5, inclusive.\n\nSample Input 1\n\nDD??S\n\nSample Output 1\n\n676\n\nWhen at least one of the ?s is replaced with a lowercase English letter, the resulting string will contain a DDoS-type string as a subsequence.\n\nSample Input 2\n\n????????????????????????????????????????\n\nSample Output 2\n\n858572093\n\nFind the count modulo 998244353.\n\nSample Input 3\n\n?D??S\n\nSample Output 3\n\n136604",
        "platform": "atcoder",
        "question_id": "abc301_f",
        "contest_id": "abc301",
        "contest_date": "2023-05-13T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "MOD = 998244353\n\ndef solve(s):\n    n = len(s)\n    # dp[i][j] = number of ways to fill first i characters such that the last j characters form a valid DDoS-type subsequence\n    # j can be 0, 1, 2, 3, 4\n    # j=0: no valid DDoS-type subsequence\n    # j=1: first char of DDoS-type subsequence\n    # j=2: first two chars of DDoS-type subsequence\n    # j=3: first three chars of DDoS-type subsequence\n    # j=4: full DDoS-type subsequence found\n    dp = [[0] * 5 for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        c = s[i]\n        for j in range(5):\n            if dp[i][j] == 0:\n                continue\n            # Try all possible replacements for c\n            if c == '?':\n                # 26 uppercase, 26 lowercase\n                for uc in range(26):\n                    ch = chr(ord('A') + uc)\n                    new_j = j\n                    # Check if adding ch forms a new DDoS-type subsequence\n                    if new_j == 0:\n                        # Start a new DDoS-type subsequence\n                        if ch.isupper():\n                            new_j = 1\n                    elif new_j == 1:\n                        # Second character of DDoS-type\n                        if ch.isupper() and ch == dp[i][j-1][0]:\n                            new_j = 2\n                        elif ch.isupper():\n                            new_j = 1\n                        else:\n                            new_j = 1\n                    elif new_j == 2:\n                        # Third character of DDoS-type\n                        if ch.islower():\n                            new_j = 3\n                    elif new_j == 3:\n                        # Fourth character of DDoS-type\n                        if ch.isupper():\n                            new_j = 4\n                    # If new_j is 4, we have a DDoS-type subsequence, so we don't want to count it\n                    if new_j == 4:\n                        continue\n                    dp[i+1][new_j] = (dp[i+1][new_j] + dp[i][j]) % MOD\n                for lc in range(26):\n                    ch = chr(ord('a') + lc)\n                    new_j = j\n                    if new_j == 0:\n                        # Start a new DDoS-type subsequence\n                        if ch.isupper():\n                            new_j = 1\n                    elif new_j == 1:\n                        # Second character of DDoS-type\n                        if ch.isupper() and ch == dp[i][j-1][0]:\n                            new_j = 2\n                        elif ch.isupper():\n                            new_j = 1\n                        else:\n                            new_j = 1\n                    elif new_j == 2:\n                        # Third character of DDoS-type\n                        if ch.islower():\n                            new_j = 3\n                    elif new_j == 3:\n                        # Fourth character of DDoS-type\n                        if ch.isupper():\n                            new_j = 4\n                    if new_j == 4:\n                        continue\n                    dp[i+1][new_j] = (dp[i+1][new_j] + dp[i][j]) % MOD\n            else:\n                # c is a fixed character\n                new_j = j\n                if new_j == 0:\n                    if c.isupper():\n                        new_j = 1\n                elif new_j == 1:\n                    if c.isupper() and c == dp[i][j-1][0]:\n                        new_j = 2\n                    elif c.isupper():\n                        new_j = 1\n                    else:\n                        new_j = 1\n                elif new_j == 2:\n                    if c.islower():\n                        new_j = 3\n                elif new_j == 3:\n                    if c.isupper():\n                        new_j = 4\n                if new_j == 4:\n                    continue\n                dp[i+1][new_j] = (dp[i+1][new_j] + dp[i][j]) % MOD\n    return dp[n][0]\n\ns = input().strip()\nprint(solve(s))"
        ],
        "code_list": [
            "MOD = 998244353\n\ndef solve(s):\n    n = len(s)\n    # dp[i][j] = number of ways to fill first i characters such that the last j characters form a valid DDoS-type subsequence\n    # j can be 0, 1, 2, 3, 4\n    # j=0: no valid DDoS-type subsequence\n    # j=1: first char of DDoS-type subsequence\n    # j=2: first two chars of DDoS-type subsequence\n    # j=3: first three chars of DDoS-type subsequence\n    # j=4: full DDoS-type subsequence found\n    dp = [[0] * 5 for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        c = s[i]\n        for j in range(5):\n            if dp[i][j] == 0:\n                continue\n            # Try all possible replacements for c\n            if c == '?':\n                # 26 uppercase, 26 lowercase\n                for uc in range(26):\n                    ch = chr(ord('A') + uc)\n                    new_j = j\n                    # Check if adding ch forms a new DDoS-type subsequence\n                    if new_j == 0:\n                        # Start a new DDoS-type subsequence\n                        if ch.isupper():\n                            new_j = 1\n                    elif new_j == 1:\n                        # Second character of DDoS-type\n                        if ch.isupper() and ch == dp[i][j-1][0]:\n                            new_j = 2\n                        elif ch.isupper():\n                            new_j = 1\n                        else:\n                            new_j = 1\n                    elif new_j == 2:\n                        # Third character of DDoS-type\n                        if ch.islower():\n                            new_j = 3\n                    elif new_j == 3:\n                        # Fourth character of DDoS-type\n                        if ch.isupper():\n                            new_j = 4\n                    # If new_j is 4, we have a DDoS-type subsequence, so we don't want to count it\n                    if new_j == 4:\n                        continue\n                    dp[i+1][new_j] = (dp[i+1][new_j] + dp[i][j]) % MOD\n                for lc in range(26):\n                    ch = chr(ord('a') + lc)\n                    new_j = j\n                    if new_j == 0:\n                        # Start a new DDoS-type subsequence\n                        if ch.isupper():\n                            new_j = 1\n                    elif new_j == 1:\n                        # Second character of DDoS-type\n                        if ch.isupper() and ch == dp[i][j-1][0]:\n                            new_j = 2\n                        elif ch.isupper():\n                            new_j = 1\n                        else:\n                            new_j = 1\n                    elif new_j == 2:\n                        # Third character of DDoS-type\n                        if ch.islower():\n                            new_j = 3\n                    elif new_j == 3:\n                        # Fourth character of DDoS-type\n                        if ch.isupper():\n                            new_j = 4\n                    if new_j == 4:\n                        continue\n                    dp[i+1][new_j] = (dp[i+1][new_j] + dp[i][j]) % MOD\n            else:\n                # c is a fixed character\n                new_j = j\n                if new_j == 0:\n                    if c.isupper():\n                        new_j = 1\n                elif new_j == 1:\n                    if c.isupper() and c == dp[i][j-1][0]:\n                        new_j = 2\n                    elif c.isupper():\n                        new_j = 1\n                    else:\n                        new_j = 1\n                elif new_j == 2:\n                    if c.islower():\n                        new_j = 3\n                elif new_j == 3:\n                    if c.isupper():\n                        new_j = 4\n                if new_j == 4:\n                    continue\n                dp[i+1][new_j] = (dp[i+1][new_j] + dp[i][j]) % MOD\n    return dp[n][0]\n\ns = input().strip()\nprint(solve(s))"
        ],
        "graded_list": [
            false
        ],
        "pass@1": 0.0,
        "metadata": [
            "{\"error\": \"TypeError(\\\"'int' object is not subscriptable\\\")\", \"error_code\": -4, \"error_message\": \"Runtime Error\", \"inputs\": \"DD??S\\n\", \"expected\": \"676\\n\"}"
        ]
    }
]